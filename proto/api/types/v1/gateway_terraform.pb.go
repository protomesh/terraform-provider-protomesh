// Code generated by protoc-gen-terraform. DO NOT EDIT.

package typesv1

import (
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"
	"encoding/json"
	"reflect"
)

func NewAwsHandlerSchema() map[string]*schema.Schema {
	return map[string]*schema.Schema{
		"handler": {
			Type:     schema.TypeList,
			MaxItems: 1,
			Optional: true,
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					"lambda": {
						Type:        schema.TypeList,
						MaxItems:    1,
						Optional:    true,
						Description: "Lambda function handler.",
						Elem: &schema.Resource{
							Schema: NewAwsHandlerLambdaFunctionSchema(),
						},
					},
				},
			},
		},
	}
}

func UnmarshalAwsHandler(obj map[string]interface{}) (map[string]interface{}, error) {
	p := map[string]interface{}{}
	if valueHandler, okHandler := obj["handler"].([]interface{}); okHandler && len(valueHandler) > 0 {
		o := valueHandler[0].(map[string]interface{})
		if oneOfVal, ok := o["lambda"]; ok {
			if valueLambdaCollection, okLambda := oneOfVal.([]interface{}); okLambda && reflect.ValueOf(valueLambdaCollection).IsValid() && !reflect.ValueOf(valueLambdaCollection).IsZero() && len(valueLambdaCollection) > 0 {
				if valueLambda, okLambda := valueLambdaCollection[0].(map[string]interface{}); okLambda {
					msg, err := UnmarshalAwsHandlerLambdaFunction(valueLambda)
					if err != nil {
						return nil, err
					}
					p["lambda"] = msg
				}
			}
		}
	}
	return p, nil
}

func UnmarshalAwsHandlerProto(obj map[string]interface{}, m proto.Message) error {
	d, err := UnmarshalAwsHandler(obj)
	if err != nil {
		return err
	}
	b, err := json.Marshal(d)
	if err != nil {
		return err
	}
	if err := protojson.Unmarshal(b, m); err != nil {
		return err
	}
	return nil
}

func MarshalAwsHandler(obj map[string]interface{}) (map[string]interface{}, error) {
	p := map[string]interface{}{}
	p["handler"] = []interface{}{}
	if _, ok := obj["lambda"]; ok {
		p["handler"] = append(p["handler"].([]interface{}), map[string]interface{}{})
		if m, ok := obj["lambda"].(map[string]interface{}); ok {
			d, err := MarshalAwsHandlerLambdaFunction(m)
			if err != nil {
				return nil, err
			}
			p["handler"].([]interface{})[0].(map[string]interface{})["lambda"] = []interface{}{d}
		}
	}
	return p, nil
}

func MarshalAwsHandlerProto(m proto.Message) (map[string]interface{}, error) {
	obj := map[string]interface{}{}
	b, err := protojson.MarshalOptions{UseProtoNames: true}.Marshal(m)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(b, &obj)
	if err != nil {
		return nil, err
	}
	return MarshalAwsHandler(obj)
}

func NewAwsHandlerLambdaFunctionSchema() map[string]*schema.Schema {
	return map[string]*schema.Schema{
		"function_name": {
			Type:        schema.TypeString,
			Optional:    true,
			Description: "Lambda function name or ARN.",
		},
		"qualifier": {
			Type:        schema.TypeString,
			Optional:    true,
			Description: "Version name of Lambda (default $LATEST).",
		},
	}
}

func UnmarshalAwsHandlerLambdaFunction(obj map[string]interface{}) (map[string]interface{}, error) {
	p := map[string]interface{}{}
	if valueFunctionName, okFunctionName := obj["function_name"].(string); okFunctionName && reflect.ValueOf(valueFunctionName).IsValid() && !reflect.ValueOf(valueFunctionName).IsZero() {
		p["function_name"] = valueFunctionName
	}
	if valueQualifier, okQualifier := obj["qualifier"].(string); okQualifier && reflect.ValueOf(valueQualifier).IsValid() && !reflect.ValueOf(valueQualifier).IsZero() {
		p["qualifier"] = valueQualifier
	}
	return p, nil
}

func UnmarshalAwsHandlerLambdaFunctionProto(obj map[string]interface{}, m proto.Message) error {
	d, err := UnmarshalAwsHandlerLambdaFunction(obj)
	if err != nil {
		return err
	}
	b, err := json.Marshal(d)
	if err != nil {
		return err
	}
	if err := protojson.Unmarshal(b, m); err != nil {
		return err
	}
	return nil
}

func MarshalAwsHandlerLambdaFunction(obj map[string]interface{}) (map[string]interface{}, error) {
	p := map[string]interface{}{}
	p["function_name"], _ = obj["function_name"].(string)
	p["qualifier"], _ = obj["qualifier"].(string)
	return p, nil
}

func MarshalAwsHandlerLambdaFunctionProto(m proto.Message) (map[string]interface{}, error) {
	obj := map[string]interface{}{}
	b, err := protojson.MarshalOptions{UseProtoNames: true}.Marshal(m)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(b, &obj)
	if err != nil {
		return nil, err
	}
	return MarshalAwsHandlerLambdaFunction(obj)
}

func NewGatewayPolicySchema() map[string]*schema.Schema {
	return map[string]*schema.Schema{
		"handlers": {
			Type:        schema.TypeList,
			Optional:    true,
			Description: "Handlers are the handlers to invoke when the source matches.  Each result of each handler is passed to the next handler.  When an error occurs, the error is returned to the client.",
			Elem: &schema.Resource{
				Schema: NewGatewayPolicyHandlerSchema(),
			},
		},
		"source": {
			Type:     schema.TypeList,
			MaxItems: 1,
			Optional: true,
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					"http": {
						Type:     schema.TypeList,
						MaxItems: 1,
						Optional: true,
						Elem: &schema.Resource{
							Schema: NewHttpSourceSchema(),
						},
					},
					"grpc": {
						Type:     schema.TypeList,
						MaxItems: 1,
						Optional: true,
						Elem: &schema.Resource{
							Schema: NewGrpcSourceSchema(),
						},
					},
				},
			},
		},
	}
}

func UnmarshalGatewayPolicy(obj map[string]interface{}) (map[string]interface{}, error) {
	p := map[string]interface{}{}
	if valueHandlers, okHandlers := obj["handlers"].([]interface{}); okHandlers && reflect.ValueOf(valueHandlers).IsValid() && !reflect.ValueOf(valueHandlers).IsZero() {
		list := valueHandlers
		r := []map[string]interface{}{}
		for _, val := range list {
			m, err := UnmarshalGatewayPolicyHandler(val.(map[string]interface{}))
			if err != nil {
				return nil, err
			}
			r = append(r, m)
		}
		p["handlers"] = r
	}
	if valueSource, okSource := obj["source"].([]interface{}); okSource && len(valueSource) > 0 {
		o := valueSource[0].(map[string]interface{})
		if oneOfVal, ok := o["http"]; ok {
			if valueHttpCollection, okHttp := oneOfVal.([]interface{}); okHttp && reflect.ValueOf(valueHttpCollection).IsValid() && !reflect.ValueOf(valueHttpCollection).IsZero() && len(valueHttpCollection) > 0 {
				if valueHttp, okHttp := valueHttpCollection[0].(map[string]interface{}); okHttp {
					msg, err := UnmarshalHttpSource(valueHttp)
					if err != nil {
						return nil, err
					}
					p["http"] = msg
				}
			}
		}
		if oneOfVal, ok := o["grpc"]; ok {
			if valueGrpcCollection, okGrpc := oneOfVal.([]interface{}); okGrpc && reflect.ValueOf(valueGrpcCollection).IsValid() && !reflect.ValueOf(valueGrpcCollection).IsZero() && len(valueGrpcCollection) > 0 {
				if valueGrpc, okGrpc := valueGrpcCollection[0].(map[string]interface{}); okGrpc {
					msg, err := UnmarshalGrpcSource(valueGrpc)
					if err != nil {
						return nil, err
					}
					p["grpc"] = msg
				}
			}
		}
	}
	return p, nil
}

func UnmarshalGatewayPolicyProto(obj map[string]interface{}, m proto.Message) error {
	d, err := UnmarshalGatewayPolicy(obj)
	if err != nil {
		return err
	}
	b, err := json.Marshal(d)
	if err != nil {
		return err
	}
	if err := protojson.Unmarshal(b, m); err != nil {
		return err
	}
	return nil
}

func MarshalGatewayPolicy(obj map[string]interface{}) (map[string]interface{}, error) {
	p := map[string]interface{}{}
	if l, ok := obj["handlers"].([]interface{}); ok {
		p["handlers"] = []interface{}{}
		for _, i := range l {
			d, err := MarshalGatewayPolicyHandler(i.(map[string]interface{}))
			if err != nil {
				return nil, err
			}
			p["handlers"] = append(p["handlers"].([]interface{}), d)
		}
	}
	p["source"] = []interface{}{}
	if _, ok := obj["http"]; ok {
		p["source"] = append(p["source"].([]interface{}), map[string]interface{}{})
		if m, ok := obj["http"].(map[string]interface{}); ok {
			d, err := MarshalHttpSource(m)
			if err != nil {
				return nil, err
			}
			p["source"].([]interface{})[0].(map[string]interface{})["http"] = []interface{}{d}
		}
	}
	if _, ok := obj["grpc"]; ok {
		p["source"] = append(p["source"].([]interface{}), map[string]interface{}{})
		if m, ok := obj["grpc"].(map[string]interface{}); ok {
			d, err := MarshalGrpcSource(m)
			if err != nil {
				return nil, err
			}
			p["source"].([]interface{})[0].(map[string]interface{})["grpc"] = []interface{}{d}
		}
	}
	return p, nil
}

func MarshalGatewayPolicyProto(m proto.Message) (map[string]interface{}, error) {
	obj := map[string]interface{}{}
	b, err := protojson.MarshalOptions{UseProtoNames: true}.Marshal(m)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(b, &obj)
	if err != nil {
		return nil, err
	}
	return MarshalGatewayPolicy(obj)
}

func NewGatewayPolicyHandlerSchema() map[string]*schema.Schema {
	return map[string]*schema.Schema{
		"handler": {
			Type:     schema.TypeList,
			MaxItems: 1,
			Optional: true,
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					"aws": {
						Type:     schema.TypeList,
						MaxItems: 1,
						Optional: true,
						Elem: &schema.Resource{
							Schema: NewAwsHandlerSchema(),
						},
					},
				},
			},
		},
	}
}

func UnmarshalGatewayPolicyHandler(obj map[string]interface{}) (map[string]interface{}, error) {
	p := map[string]interface{}{}
	if valueHandler, okHandler := obj["handler"].([]interface{}); okHandler && len(valueHandler) > 0 {
		o := valueHandler[0].(map[string]interface{})
		if oneOfVal, ok := o["aws"]; ok {
			if valueAwsCollection, okAws := oneOfVal.([]interface{}); okAws && reflect.ValueOf(valueAwsCollection).IsValid() && !reflect.ValueOf(valueAwsCollection).IsZero() && len(valueAwsCollection) > 0 {
				if valueAws, okAws := valueAwsCollection[0].(map[string]interface{}); okAws {
					msg, err := UnmarshalAwsHandler(valueAws)
					if err != nil {
						return nil, err
					}
					p["aws"] = msg
				}
			}
		}
	}
	return p, nil
}

func UnmarshalGatewayPolicyHandlerProto(obj map[string]interface{}, m proto.Message) error {
	d, err := UnmarshalGatewayPolicyHandler(obj)
	if err != nil {
		return err
	}
	b, err := json.Marshal(d)
	if err != nil {
		return err
	}
	if err := protojson.Unmarshal(b, m); err != nil {
		return err
	}
	return nil
}

func MarshalGatewayPolicyHandler(obj map[string]interface{}) (map[string]interface{}, error) {
	p := map[string]interface{}{}
	p["handler"] = []interface{}{}
	if _, ok := obj["aws"]; ok {
		p["handler"] = append(p["handler"].([]interface{}), map[string]interface{}{})
		if m, ok := obj["aws"].(map[string]interface{}); ok {
			d, err := MarshalAwsHandler(m)
			if err != nil {
				return nil, err
			}
			p["handler"].([]interface{})[0].(map[string]interface{})["aws"] = []interface{}{d}
		}
	}
	return p, nil
}

func MarshalGatewayPolicyHandlerProto(m proto.Message) (map[string]interface{}, error) {
	obj := map[string]interface{}{}
	b, err := protojson.MarshalOptions{UseProtoNames: true}.Marshal(m)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(b, &obj)
	if err != nil {
		return nil, err
	}
	return MarshalGatewayPolicyHandler(obj)
}

func NewHttpSourceSchema() map[string]*schema.Schema {
	return map[string]*schema.Schema{
		"method": {
			Type:         schema.TypeString,
			ValidateFunc: validation.StringInSlice([]string{"HTTP_METHOD_UNDEFINED", "HTTP_METHOD_GET", "HTTP_METHOD_HEAD", "HTTP_METHOD_POST", "HTTP_METHOD_PUT", "HTTP_METHOD_DELETE", "HTTP_METHOD_CONNECT", "HTTP_METHOD_OPTIONS", "HTTP_METHOD_TRACE", "HTTP_METHOD_PATCH"}, false),
			Optional:     true,
			Description:  "HTTP method to match against the URL.  If you speicify HTT_METHOD_UNDEFINED, the method is not considered when  matching.",
		},
		"path": {
			Type:        schema.TypeString,
			Optional:    true,
			Description: "Path to match against the URL.",
		},
		"exact_path_match": {
			Type:        schema.TypeBool,
			Optional:    true,
			Description: "If true, the path must match exactly.  Otherwise, the path must match using the prefix match semantics (Radix Tree match longest operation).",
		},
	}
}

func UnmarshalHttpSource(obj map[string]interface{}) (map[string]interface{}, error) {
	p := map[string]interface{}{}
	if valueMethod, okMethod := obj["method"].(string); okMethod && reflect.ValueOf(valueMethod).IsValid() && !reflect.ValueOf(valueMethod).IsZero() {
		p["method"] = valueMethod
	}
	if valuePath, okPath := obj["path"].(string); okPath && reflect.ValueOf(valuePath).IsValid() && !reflect.ValueOf(valuePath).IsZero() {
		p["path"] = valuePath
	}
	if valueExactPathMatch, okExactPathMatch := obj["exact_path_match"].(bool); okExactPathMatch && reflect.ValueOf(valueExactPathMatch).IsValid() && !reflect.ValueOf(valueExactPathMatch).IsZero() {
		p["exact_path_match"] = valueExactPathMatch
	}
	return p, nil
}

func UnmarshalHttpSourceProto(obj map[string]interface{}, m proto.Message) error {
	d, err := UnmarshalHttpSource(obj)
	if err != nil {
		return err
	}
	b, err := json.Marshal(d)
	if err != nil {
		return err
	}
	if err := protojson.Unmarshal(b, m); err != nil {
		return err
	}
	return nil
}

func MarshalHttpSource(obj map[string]interface{}) (map[string]interface{}, error) {
	p := map[string]interface{}{}
	p["method"], _ = obj["method"].(string)
	p["path"], _ = obj["path"].(string)
	p["exact_path_match"], _ = obj["exact_path_match"].(bool)
	return p, nil
}

func MarshalHttpSourceProto(m proto.Message) (map[string]interface{}, error) {
	obj := map[string]interface{}{}
	b, err := protojson.MarshalOptions{UseProtoNames: true}.Marshal(m)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(b, &obj)
	if err != nil {
		return nil, err
	}
	return MarshalHttpSource(obj)
}

func NewGrpcSourceSchema() map[string]*schema.Schema {
	return map[string]*schema.Schema{
		"method_name": {
			Type:        schema.TypeString,
			Optional:    true,
			Description: "Full method name of the gRPC method (/my.package.GrpcService/GrpcMethod).",
		},
		"exact_method_name_match": {
			Type:        schema.TypeBool,
			Optional:    true,
			Description: "If true, the method name must match exactly.  Otherwise, the method name must match using the prefix match semantics (Radix Tree match longest operation).",
		},
	}
}

func UnmarshalGrpcSource(obj map[string]interface{}) (map[string]interface{}, error) {
	p := map[string]interface{}{}
	if valueMethodName, okMethodName := obj["method_name"].(string); okMethodName && reflect.ValueOf(valueMethodName).IsValid() && !reflect.ValueOf(valueMethodName).IsZero() {
		p["method_name"] = valueMethodName
	}
	if valueExactMethodNameMatch, okExactMethodNameMatch := obj["exact_method_name_match"].(bool); okExactMethodNameMatch && reflect.ValueOf(valueExactMethodNameMatch).IsValid() && !reflect.ValueOf(valueExactMethodNameMatch).IsZero() {
		p["exact_method_name_match"] = valueExactMethodNameMatch
	}
	return p, nil
}

func UnmarshalGrpcSourceProto(obj map[string]interface{}, m proto.Message) error {
	d, err := UnmarshalGrpcSource(obj)
	if err != nil {
		return err
	}
	b, err := json.Marshal(d)
	if err != nil {
		return err
	}
	if err := protojson.Unmarshal(b, m); err != nil {
		return err
	}
	return nil
}

func MarshalGrpcSource(obj map[string]interface{}) (map[string]interface{}, error) {
	p := map[string]interface{}{}
	p["method_name"], _ = obj["method_name"].(string)
	p["exact_method_name_match"], _ = obj["exact_method_name_match"].(bool)
	return p, nil
}

func MarshalGrpcSourceProto(m proto.Message) (map[string]interface{}, error) {
	obj := map[string]interface{}{}
	b, err := protojson.MarshalOptions{UseProtoNames: true}.Marshal(m)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(b, &obj)
	if err != nil {
		return nil, err
	}
	return MarshalGrpcSource(obj)
}
